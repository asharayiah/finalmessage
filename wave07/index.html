<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FinalMessage • Wave-07 • CMB Stream First</title>
<style>
  :root{--ink:#e6e7ea;--muted:#a3a7ad;--bg:#0b0d11;--panel:rgba(17,20,26,.65);--border:rgba(255,255,255,.08)}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header,footer{padding:12px 16px;border-bottom:1px solid var(--border)}
  footer{border-top:1px solid var(--border);border-bottom:none;color:var(--muted)}
  main{max-width:1200px;margin:0 auto;padding:16px}
  .tabs{display:flex;gap:10px;margin:.5rem 0 1rem}
  .tab{padding:.6rem .9rem;border:1px solid var(--border);background:var(--panel);border-radius:12px;cursor:pointer;font-weight:600}
  .tab[aria-selected="true"]{background:#16202b;border-color:#26455f}
  .panel{display:none}
  .panel[aria-hidden="false"]{display:block}
  figure.video{margin:0}
  figure.video video{max-width:100%;height:auto;display:block;border-radius:12px}
  figure.video figcaption{color:var(--muted);font-size:.9rem;margin-top:.5rem}

  /* UI above canvas */
  .ui{
    position:fixed; top:12px; right:12px; display:flex; flex-direction:column; gap:8px;
    background:var(--panel); backdrop-filter:blur(6px); -webkit-backdrop-filter:blur(6px);
    border:1px solid var(--border); padding:12px 14px; border-radius:12px; z-index:9999
  }
  .ui label{font-size:12px;opacity:.9}
  .ui button,.ui input[type="range"],.ui input[type="checkbox"]{width:260px}
  .credit{position:fixed;left:12px;bottom:10px;font-size:12px;color:var(--muted);opacity:.9;z-index:9999}

  /* Canvas behind overlays so clicks work */
  canvas{display:block;width:100%;height:100%;position:fixed;inset:0;z-index:0}

  .notice{margin-top:10px;color:#c8cccf;font-size:.9rem;opacity:.9}
  #recStatus{font-size:12px;opacity:.9}
</style>
</head>
<body>
  <header><strong>FinalMessage</strong> • Wave-07</header>

  <main>
    <h1>Cosmic Microwave Background???</h1>

    <div class="tabs" role="tablist" aria-label="Wave-07 modes">
      <button id="tab-stream" class="tab" role="tab" aria-selected="true"  aria-controls="panel-stream">Concept: Stream of Waves</button>
      <button id="tab-video"  class="tab" role="tab" aria-selected="false" aria-controls="panel-video">Official ESA Video</button>
    </div>

    <!-- Panel: Concept Stream-of-Waves (Three.js) — DEFAULT -->
    <section id="panel-stream" class="panel" role="tabpanel" aria-hidden="false">
      <div id="ui" class="ui">
        <button id="btnWaves">Pause Waves</button>
        <label>Wave Speed <input id="speed" type="range" min="0" max="2" step="0.01" value="0.6"></label>
        <label>Wave Count <input id="count" type="range" min="4" max="32" step="1" value="14"></label>
        <label>Brightness <input id="bright" type="range" min="0" max="1.2" step="0.01" value="0.5"></label>
        <label><input id="starsToggle" type="checkbox" checked> Show Stars / Galaxy Sprites</label>
        <label>Star Density <input id="starCount" type="range" min="1000" max="20000" step="1000" value="8000"></label>
        <button id="btnRecord">Start Recording</button>
        <small id="recStatus">Ready</small>
        <button id="btnDownload" disabled>Download Last Recording</button>
        <button id="btnTest5">Test 5s Recording</button>
        <button id="btnForce">Force Finalize</button>
        <small style="opacity:.75;display:block;margin-top:4px">If nothing downloads, use Chrome/Edge and open via HTTPS/HTTP (GitHub Pages or localhost).</small>
      </div>
      <div class="credit">CMB texture: ESA / Planck Collaboration (equirectangular). Concept demo — not a literal time series.</div>
    </section>

    <!-- Panel: Official ESA Video (secondary) -->
    <section id="panel-video" class="panel" role="tabpanel" aria-hidden="true">
      <figure class="video">
        <video controls preload="metadata" poster="../assets/cmb/poster_1920.jpg" width="960">
          <source src="../assets/cmb/cmb_movie.webm" type="video/webm">
          <source src="../assets/cmb/cmb_movie_720_tight.mp4" type="video/mp4">
          <track kind="captions" srclang="en" src="../assets/cmb/en.srt" label="English" default>
          Sorry, your browser doesn’t support embedded videos.
        </video>
        <figcaption>Planck’s view of the CMB — <small>ESA / Planck Collaboration</small></figcaption>
      </figure>
    </section>
  </main>

  <footer>© FinalMessage</footer>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
    "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js"
  }
}
</script>
  <script type="module">
    // Tabs (Stream is default)
    const tabVideo  = document.getElementById('tab-video');
    const tabStream = document.getElementById('tab-stream');
    const panelVideo  = document.getElementById('panel-video');
    const panelStream = document.getElementById('panel-stream');

    function selectTab(which){
      const isStream = which === 'stream';
      tabStream.setAttribute('aria-selected', String(isStream));
      tabVideo.setAttribute('aria-selected', String(!isStream));
      panelStream.setAttribute('aria-hidden', String(!isStream));
      panelVideo.setAttribute('aria-hidden', String(isStream));
      if(isStream && !window.__CMB_STREAM_BOOTED__) bootStream();
    }
    tabVideo.addEventListener('click',  ()=>selectTab('video'));
    tabStream.addEventListener('click', ()=>selectTab('stream'));
    selectTab('stream'); // open stream by default

    // --- STREAM IMPLEMENTATION ---
    async function bootStream(){
const THREE = await import('three');
const { OrbitControls } = await import('three/examples/jsm/controls/OrbitControls.js');

      if(window.__CMB_STREAM_BOOTED__) return; window.__CMB_STREAM_BOOTED__=true;

      // Use CDN URL imports (avoids bare module specifier errors)
      const THREE = await import('https://unpkg.com/three@0.161.0/build/three.module.js');
      const { OrbitControls } = await import('https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js');

      const W=window.innerWidth,H=window.innerHeight;
      const renderer=new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
      renderer.setSize(W,H); renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
      // Ensure canvas sits behind UI so clicks work
      Object.assign(renderer.domElement.style,{position:'fixed',inset:'0',zIndex:'0'});
      document.body.appendChild(renderer.domElement);

      const scene=new THREE.Scene(); scene.background=new THREE.Color(0x0b0d11);
      const camera=new THREE.PerspectiveCamera(55,W/H,0.01,2000); camera.position.set(0,0,2.25);
      const controls=new OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.05; controls.minDistance=1.3; controls.maxDistance=6;

      scene.add(new THREE.AmbientLight(0xffffff,0.25));
      const dl=new THREE.DirectionalLight(0xffffff,0.2); dl.position.set(1,1,1); scene.add(dl);

      // Pick best texture (4K preferred, 2K fallback)
      function pickCmbTexturePath(maxTex){
        if (maxTex >= 4096) return '../assets/cmb/cmb_equirectangular.jpg';      // 4096×2048
        return '../assets/cmb/cmb_equirectangular_2k.jpg';                        // 2048×1024
      }
      const glCanvas = document.createElement('canvas');
      const gl = glCanvas.getContext('webgl2') || glCanvas.getContext('webgl');
      const maxTex = gl ? gl.getParameter(gl.MAX_TEXTURE_SIZE) : 4096;
      const cmbPath = pickCmbTexturePath(maxTex);

      // CMB on inside of sphere (flip horizontally for inside view)
      const texLoader=new THREE.TextureLoader();
      texLoader.setCrossOrigin('anonymous'); // safe even if same-origin
      texLoader.load(cmbPath,(tex)=>{
        tex.wrapS = THREE.RepeatWrapping; tex.repeat.x = -1; tex.offset.x = 1;
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        const geo = new THREE.SphereGeometry(1.0,128,64);
        const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.BackSide });
        scene.add(new THREE.Mesh(geo, mat));
      }, undefined, (err)=>console.error('Failed to load CMB texture:', err));

      // Wavefront shells (concept stream)
      const waveGroup=new THREE.Group(); scene.add(waveGroup);
      let waveCount=14, waveSpeed=0.6, brightness=0.5, running=true;
      const baseGeo=new THREE.SphereGeometry(1.6,96,48);
      function buildWaves(){
        waveGroup.clear();
        for(let i=0;i<waveCount;i++){
          const mat=new THREE.ShaderMaterial({
            transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
            uniforms:{ uTime:{value:0}, uRadius:{value:1.8+i*0.12}, uSpeed:{value:waveSpeed}, uBrightness:{value:brightness} },
            vertexShader:`varying vec3 v; void main(){ v=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
            fragmentShader:`varying vec3 v; uniform float uTime,uRadius,uSpeed,uBrightness; void main(){ float d=length(v); float p=uRadius-uSpeed*uTime; float band=exp(-pow((d-p),2.0)*60.0); float glow=band*uBrightness; float fade=smoothstep(0.02,0.0,d-0.15); float a=clamp(glow*fade,0.0,1.0); if(a<0.002) discard; gl_FragColor=vec4(vec3(0.55,0.75,1.0)*glow+vec3(0.1)*a*0.3,a); }`
          });
          waveGroup.add(new THREE.Mesh(baseGeo, mat));
        }
      }
      buildWaves();

      // Stars / galaxy-like sprites
      let stars=null, starCount=8000, starsVisible=true;
      function buildStars(){
        if(stars){ scene.remove(stars); stars.geometry.dispose(); stars.material.dispose(); stars=null; }
        const geom=new THREE.BufferGeometry();
        const N=starCount; const pos=new Float32Array(N*3); const col=new Float32Array(N*3); const size=new Float32Array(N);
        for(let i=0;i<N;i++){
          const R=1.2+Math.random()*4.0;
          const th=Math.acos(2*Math.random()-1), ph=2*Math.PI*Math.random();
          const x=R*Math.sin(th)*Math.cos(ph), y=R*Math.cos(th), z=R*Math.sin(th)*Math.sin(ph);
          pos[3*i]=x; pos[3*i+1]=y; pos[3*i+2]=z;
          const tint=0.8+0.2*Math.random(); col[3*i]=tint; col[3*i+1]=tint*0.9; col[3*i+2]=1.0;
          size[i]=3.0+3.0*Math.random();
        }
        geom.setAttribute('position',new THREE.BufferAttribute(pos,3));
        geom.setAttribute('color',new THREE.BufferAttribute(col,3));
        geom.setAttribute('aSize',new THREE.BufferAttribute(size,1));
        const mat=new THREE.ShaderMaterial({
          transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, vertexColors:true,
          uniforms:{ uTime:{value:0} },
          vertexShader:`attribute float aSize; varying vec3 vc; uniform float uTime; void main(){ vc=color; float t=uTime*0.06; float a=smoothstep(0.0,1.0,clamp((length(position)-1.0)*0.25-(1.2-t),0.0,1.0)); vec4 mv=modelViewMatrix*vec4(position,1.0); gl_PointSize=aSize*a*(300.0/-mv.z); gl_Position=projectionMatrix*mv; }`,
          fragmentShader:`varying vec3 vc; void main(){ vec2 q=gl_PointCoord-0.5; float r=length(q); float m=exp(-8.0*r*r); gl_FragColor=vec4(vc*m,m); }`
        });
        stars=new THREE.Points(geom,mat); stars.visible=starsVisible; scene.add(stars);
      }
      buildStars();

      // ---- Recorder (diagnostics + Safari-aware) ----
      const $ = s=>document.querySelector(s);
      const btnRec = $('#btnRecord'), btnDL = $('#btnDownload'), recStatus = $('#recStatus');
      const testBtn = $('#btnTest5'), forceBtn = $('#btnForce');
      const canvas = renderer.domElement;

      let recorder = null, chunks = [], lastBlobUrl = null, lastMime = null, bytes = 0, chunkCount = 0;

      function isSafari(){
        const ua = navigator.userAgent;
        const is_safari = /^((?!chrome|android).)*safari/i.test(ua);
        const is_ios = /iPad|iPhone|iPod/.test(ua);
        return is_safari || is_ios;
      }

      function pickMime(){
        const mp4s = ['video/mp4;codecs="h264,aac"','video/mp4'];
        const webms = ['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
        const candidates = isSafari() ? [...mp4s, ...webms] : [...webms, ...mp4s];
        for (const m of candidates){ if (window.MediaRecorder?.isTypeSupported?.(m)) return m; }
        return '';
      }

      function humanBytes(n){ if(!n) return '0 B'; const u=['B','KB','MB','GB']; let i=0; while(n>=1024&&i<u.length-1){n/=1024;i++;} return n.toFixed(1)+' '+u[i]; }
      function setStatus(t){ recStatus.textContent = t; }
      function enableDownload(url){
        lastBlobUrl = url; btnDL.disabled = false;
        btnDL.onclick = () => {
          const ext = (lastMime && lastMime.startsWith('video/mp4')) ? 'mp4' : 'webm';
          const a = Object.assign(document.createElement('a'), { href: url, download: `stream_of_waves.${ext}` });
          document.body.appendChild(a); a.click(); a.remove();
        };
      }

      function startRecorder(){
        if (!canvas.captureStream) { setStatus('captureStream unsupported. Use Chrome/Edge via HTTPS/HTTP.'); alert('Use Chrome/Edge and open via https:// or http://localhost'); return false; }
        const stream = canvas.captureStream(30);
        const mime = pickMime(); if(!mime){ setStatus('No supported codec for MediaRecorder.'); alert('No supported codec. Try Chrome/Edge.'); return false; }
        lastMime = mime; chunks = []; bytes = 0; chunkCount = 0;

        // ~1.4 Mbps video keeps files small for GitHub Pages
        recorder = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 1_400_000 });
        recorder.ondataavailable = e => { if (e.data && e.data.size) { chunks.push(e.data); bytes += e.data.size; chunkCount++; setStatus(`Recording… chunks=${chunkCount}, ${humanBytes(bytes)}`); } };
        recorder.onerror = e => { console.error(e); setStatus('Recorder error (see console).'); };
        recorder.onstop = () => {
          try {
            const blob = new Blob(chunks, { type: lastMime || 'video/webm' });
            if (!blob.size) { setStatus('No data captured. Try Test 5s.'); return; }
            const url = URL.createObjectURL(blob); enableDownload(url);
            const ext = (lastMime && lastMime.startsWith('video/mp4')) ? 'mp4' : 'webm';
            const a = Object.assign(document.createElement('a'), { href: url, download: `stream_of_waves.${ext}` });
            document.body.appendChild(a); a.click(); a.remove();
            setStatus(`Saved ${humanBytes(blob.size)}. Use Download Last Recording if needed.`);
          } finally { recorder = null; btnRec.textContent = 'Start Recording'; }
        };
        recorder.start(1000); // rolling chunks each second
        btnRec.textContent = 'Stop Recording';
        setStatus('Recording… chunks=0, 0 B');
        return true;
      }

      btnRec.onclick = () => {
        try {
          if (!recorder) {
            startRecorder();
          } else {
            try { recorder.requestData(); } catch(e){}
            setTimeout(()=>{ try{ recorder.stop(); }catch(e){} }, 150);
            setStatus('Finalizing…');
          }
        } catch (err) { console.error(err); setStatus('Could not start recorder (see console).'); recorder = null; btnRec.textContent='Start Recording'; }
      };

      document.getElementById('btnWaves').onclick = () => {
        running = !running;
        document.getElementById('btnWaves').textContent = running ? 'Pause Waves' : 'Resume Waves';
      };

      document.getElementById('speed').oninput=e=>{ waveSpeed=parseFloat(e.target.value); waveGroup.children.forEach(m=>m.material.uniforms.uSpeed.value=waveSpeed); };
      document.getElementById('bright').oninput=e=>{ brightness=parseFloat(e.target.value); waveGroup.children.forEach(m=>m.material.uniforms.uBrightness.value=brightness); };
      document.getElementById('count').oninput=e=>{ waveCount=parseInt(e.target.value,10); buildWaves(); };
      document.getElementById('starsToggle').onchange=e=>{ starsVisible=e.target.checked; if(stars) stars.visible=starsVisible; };
      document.getElementById('starCount').oninput=e=>{ starCount=parseInt(e.target.value,10); buildStars(); };

      document.getElementById('btnTest5').onclick = async () => {
        if (recorder) return;
        if (!startRecorder()) return;
        await new Promise(r => setTimeout(r, 5200));
        try { recorder.requestData(); } catch(e){}
        setTimeout(()=>{ try{ recorder.stop(); }catch(e){} }, 150);
        setStatus('Finalizing test…');
      };

      document.getElementById('btnForce').onclick = () => {
        if (!recorder) { setStatus('Nothing to finalize.'); return; }
        try { recorder.requestData(); } catch(e){}
        try { recorder.stop(); } catch(e){}
        setStatus('Forcing finalize…');
      };

      // Animate
      const t0 = performance.now();
      function tick(now){
        requestAnimationFrame(tick);
        const t=(now - t0)/1000;
        if(running){
          waveGroup.children.forEach((m,i)=>{ m.material.uniforms.uTime.value=t+i*0.45; });
          if(stars){ stars.material.uniforms.uTime.value=t; }
        }
        controls.update(); renderer.render(scene,camera);
      }
      requestAnimationFrame(tick);

      // Resize
      window.addEventListener('resize',()=>{
        const w=window.innerWidth,h=window.innerHeight;
        renderer.setSize(w,h); camera.aspect=w/h; camera.updateProjectionMatrix();
      });
    }
  </script>
</body>
</html>




